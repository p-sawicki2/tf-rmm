{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d28e2da7_fd4a75f9",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-04T10:47:15Z",
      "side": 1,
      "message": "The RMM granule state machine will not allow undelegating a granule which is not in state \"delegated\". \n\nWhen a granule is transitioned from \"delegated\" to any other state like \"REC, RD, RTT, DATA\" and then transitioned back to \"delegated\", there is a memzero() done.\n\nSee this query https://github.com/search?q\u003drepo%3ATF-RMM%2Ftf-rmm+memzero\u0026type\u003dcode\n\nDid you notice any case when a buffer was non zeroed when undelegate() was called?",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ac2e03e_6edaff0c",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-04T16:48:22Z",
      "side": 1,
      "message": "Sorry where is it being cleared for DATA before undelegation? I didnt see it for DATA granules before undelegation, for example, granules allocated to realm, running out of it and then we are destroying a realm, i dont see it being cleared, at least not in an obvious way.\nWouldnt it be safer and simpler to do it in one place before undelegate, than to spread it around code to ensure a granule is always zeroed before undelegation?\nit is a huge security issue obviously if we miss a memzero and this seems safer, as we add more features, granule types etc.\nif it helps, i can remove the redundant memzero in other places in this patch, to unify the memzero.",
      "parentUuid": "d28e2da7_fd4a75f9",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79f5143e_92ffdd90",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-05T09:13:01Z",
      "side": 1,
      "message": "The RMI_DATA_DESTROY will do the clearing of the buffer. The code is here : https://github.com/TF-RMM/tf-rmm/blob/81f9c7f6384e270bb13617178c112163d9d9b426/runtime/rmi/rtt.c#L1090\n\nEvery RMI_*_DESTROY call will have a memzero of the granule on success [1].\n\nThe state transition need not go via undelegation always. For example, this flow is allowed : DELEGATED -\u003e RD -\u003e DELEGATED -\u003e RD.\n\nThe first RD may be for 1 realm and the second RD could be for another Realm. Hence it is essential to scrub the granule when transitioning from any other state to DELEGATED state. \n\nYes, I agree it would be better to have it at one place, but due to transitions as described above, we cannot avoid at the DESTROY calls [2].\n\nPerhaps `granule_set_state(DELEGATED)` can do the memzero if the state is being transitioned from one of the REALM related states ?\n\n[1] If per world encryption is available, then scrubbing on returning the granule back to NS may not be so important.\n\n[2] When FEAT_MEC is implemented, depending on whether the RD, REC, RTTs are all encrypted using the per-realm key, perhaps this needs re-evaluation.",
      "parentUuid": "0ac2e03e_6edaff0c",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f997c02_7f75e616",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-06T00:40:04Z",
      "side": 1,
      "message": "oof, yes missed it in destroy, and yes agree with that transition being valid.\n\nFor [1], i think scrubbing is still important depending on the type of encryption used. If you use something like AES-XTS, which will be typical since using something like AES-GCM for memory encrytpion is very expensive to implement, there are attacks that can be used on low entropy data to get back plain text, so i think scrubbing regardless of MEC is important. Same for [2].\nEven with FEAT_MEC, all data is in plain-text in the cache hierarchy, and if we dont go through cache maintenance to PoE, which i dont believe we do in the transition example you mentioned above, one realm CAN read other reams stale data.\n\nAre you okay if i update the patch to memzero in granule_set_state to DELEGATED? I    agree with that.",
      "parentUuid": "79f5143e_92ffdd90",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}