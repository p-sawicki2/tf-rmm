{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d28e2da7_fd4a75f9",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-04T10:47:15Z",
      "side": 1,
      "message": "The RMM granule state machine will not allow undelegating a granule which is not in state \"delegated\". \n\nWhen a granule is transitioned from \"delegated\" to any other state like \"REC, RD, RTT, DATA\" and then transitioned back to \"delegated\", there is a memzero() done.\n\nSee this query https://github.com/search?q\u003drepo%3ATF-RMM%2Ftf-rmm+memzero\u0026type\u003dcode\n\nDid you notice any case when a buffer was non zeroed when undelegate() was called?",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ac2e03e_6edaff0c",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-04T16:48:22Z",
      "side": 1,
      "message": "Sorry where is it being cleared for DATA before undelegation? I didnt see it for DATA granules before undelegation, for example, granules allocated to realm, running out of it and then we are destroying a realm, i dont see it being cleared, at least not in an obvious way.\nWouldnt it be safer and simpler to do it in one place before undelegate, than to spread it around code to ensure a granule is always zeroed before undelegation?\nit is a huge security issue obviously if we miss a memzero and this seems safer, as we add more features, granule types etc.\nif it helps, i can remove the redundant memzero in other places in this patch, to unify the memzero.",
      "parentUuid": "d28e2da7_fd4a75f9",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79f5143e_92ffdd90",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-05T09:13:01Z",
      "side": 1,
      "message": "The RMI_DATA_DESTROY will do the clearing of the buffer. The code is here : https://github.com/TF-RMM/tf-rmm/blob/81f9c7f6384e270bb13617178c112163d9d9b426/runtime/rmi/rtt.c#L1090\n\nEvery RMI_*_DESTROY call will have a memzero of the granule on success [1].\n\nThe state transition need not go via undelegation always. For example, this flow is allowed : DELEGATED -\u003e RD -\u003e DELEGATED -\u003e RD.\n\nThe first RD may be for 1 realm and the second RD could be for another Realm. Hence it is essential to scrub the granule when transitioning from any other state to DELEGATED state. \n\nYes, I agree it would be better to have it at one place, but due to transitions as described above, we cannot avoid at the DESTROY calls [2].\n\nPerhaps `granule_set_state(DELEGATED)` can do the memzero if the state is being transitioned from one of the REALM related states ?\n\n[1] If per world encryption is available, then scrubbing on returning the granule back to NS may not be so important.\n\n[2] When FEAT_MEC is implemented, depending on whether the RD, REC, RTTs are all encrypted using the per-realm key, perhaps this needs re-evaluation.",
      "parentUuid": "0ac2e03e_6edaff0c",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f997c02_7f75e616",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-06T00:40:04Z",
      "side": 1,
      "message": "oof, yes missed it in destroy, and yes agree with that transition being valid.\n\nFor [1], i think scrubbing is still important depending on the type of encryption used. If you use something like AES-XTS, which will be typical since using something like AES-GCM for memory encrytpion is very expensive to implement, there are attacks that can be used on low entropy data to get back plain text, so i think scrubbing regardless of MEC is important. Same for [2].\nEven with FEAT_MEC, all data is in plain-text in the cache hierarchy, and if we dont go through cache maintenance to PoE, which i dont believe we do in the transition example you mentioned above, one realm CAN read other reams stale data.\n\nAre you okay if i update the patch to memzero in granule_set_state to DELEGATED? I    agree with that.",
      "parentUuid": "79f5143e_92ffdd90",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93fc2831_354f9602",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-06T01:26:30Z",
      "side": 1,
      "message": "btw, i confirmed with one of our memory security architects as well, and he said it is best that we scrub granules regardless of MEC or memory encryption, since there will always be some timing or other corner case in the cache hierarchy that can create cross realm leaks if we dont scrub, specifically for the transition case you mentioned...\nNow i\u0027m more paranoid and think we should make sure cross realm and cross PAS should scrub memory, and i think your solution should work very well :)",
      "parentUuid": "8f997c02_7f75e616",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c88a8e65_ca2b87ad",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-08T08:56:32Z",
      "side": 1,
      "message": "OK, good to know. We will keep the software scrubs then regardless of MEC and other per world encryption schemes.\n\n\u003e Are you okay if i update the patch to memzero in granule_set_state to DELEGATED? I agree with that.\n\nI just realized that it may be more difficult than I initially envisaged. The buffer may or maynot be mapped and this is only known to caller and not passed to this function. \n\nThe current scheme of ensuring scrub of granule as part of RMI_*_DESTROY is not too problematic to review and upkeep. This is part of the Threat model of RMM and I would expect maintainers of RMM to be aware of this threat. \n\nBut if there is a rationalization possible, we can evaluate it.",
      "parentUuid": "93fc2831_354f9602",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da414eeb_2ab9dcfa",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-08T14:53:01Z",
      "side": 1,
      "message": "I’m not sure “maintainers to be aware” is scalable. as the rmm grows in features and functionality, one of them is bound to slip through. the rationalization is pretty simple, in that you make something that is expected to be common, in common code, so you don’t need to rely on review and upkeep, which is manual and error prone so I’m surprised by the recommendation. the threat is not obvious too since as the discussion shows, there is a tendency to assume, for example, MEC would solve it and someone may remove it and it gets through review, so having a single place where the scrubbing happens and rationale explained would be closer to fool proof. I think adding a glad to map or unmap is not difficult to do either.\nhaving said that if you insist, I can abandon the change. my preference would be have a single place where scrubbing is ensured to happen.",
      "parentUuid": "c88a8e65_ca2b87ad",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4b4638f_96e617dd",
        "filename": "runtime/rmi/granule.c",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-08T15:18:59Z",
      "side": 1,
      "message": "It is indeed preferable to have a single place where the scrub is done but my worry is that the changes will become unwieldy if the call chain is more that 2 levels , as we now have to pass-through the detail about the buffer being mapped or unmapped to this set_state() API from the top level caller.\n\nI am open to the idea of rationalizing it, hence if you can prototype the change, we can evaluate how the changes look and then make a decision.\n\nIn terms of maintenance, we may be able to add a test for this which can detect if the granule is \"non-zero\" for any granule associated RMI_*_CREATE API. We have several frameworks ranging from CBMC, to unit tests, so potentially we can define a test for this case.",
      "parentUuid": "da414eeb_2ab9dcfa",
      "revId": "2f4fb668107e18d2938895ef83855d84ba94cf45",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}