{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bd493908_e80f291c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-12T17:50:47Z",
      "side": 1,
      "message": "Either prototype a large token (10 KB) in fake_host and ensure that the sequence can work.\n\nor reduce the buf_len to 100 bytes when RMM is requesting EL3 for platform token to see the flow work.",
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a208513_3e6b48f0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-17T21:28:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bd493908_e80f291c",
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7e9c13f_527ad08f",
        "filename": "lib/rmm_el3_ifc/include/rmm_el3_ifc.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-12T17:50:47Z",
      "side": 1,
      "message": "I think we dont need the new error code. See comment on next file.",
      "range": {
        "startLine": 42,
        "startChar": 8,
        "endLine": 42,
        "endChar": 42
      },
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0bb49f1_8f9583ac",
        "filename": "lib/rmm_el3_ifc/include/rmm_el3_ifc.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-17T21:28:09Z",
      "side": 1,
      "message": "Replaced with E_RMM_GET_PLAT_TOKEN_END_REACHED to indicate that the token has been fully retrieved, as discussed offline.",
      "parentUuid": "a7e9c13f_527ad08f",
      "range": {
        "startLine": 42,
        "startChar": 8,
        "endLine": 42,
        "endChar": 42
      },
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e4460ef_ed074984",
        "filename": "lib/rmm_el3_ifc/src/rmm_el3_runtime.c",
        "patchSetId": 2
      },
      "lineNbr": 77,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-12T17:50:47Z",
      "side": 1,
      "message": "I think this should be format of the EL3 call\n\n\ninput Args :\n     buffer addr, buffer len, hash size\n\noutput args :\n     return code, token_len, remaining_len\n\n\nWhen RMM first calls EL3, it needs to provide `hash_size` to EL3 after ensuring it has copied the hash to buffer.\n\nEL3 then returns with token in buffer, token len in x1 and indicates SUCCESS.\nIf token does not fit in buffer, then EL3 set remaining_len to whatever is remaining length of the token.  If RMM is able to accommodate in its token buffer, then -\n\nRMM calls EL3, but this time , it sets hash size to 0. EL3 then progresses to copy the token to the buffer and  sets the remaining_len.\n\nRMM on returning from EL3 copies the rest of token to buffer and checks remaining_len. If 0, exit the flow, else continue loop.",
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b879776_876042d7",
        "filename": "lib/rmm_el3_ifc/src/rmm_el3_runtime.c",
        "patchSetId": 2
      },
      "lineNbr": 77,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-12T17:59:12Z",
      "side": 1,
      "message": "So, if I understood correctly, I should remove the offset argument from the EL3 call. If that\u0027s the case, how does TF-A know the position in the token to copy bytes from? Shall I keep an offset variable in TF-A to handle this?",
      "parentUuid": "9e4460ef_ed074984",
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "917953bb_bdcd8128",
        "filename": "lib/rmm_el3_ifc/src/rmm_el3_runtime.c",
        "patchSetId": 2
      },
      "lineNbr": 77,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-15T13:48:29Z",
      "side": 1,
      "message": "Good point. Yes, TF-A can internally maintain a counter for tracking the offset as part of each invocation of get_platform_token() call. \n\nThe reason is that fact the TF-A itself maybe receiving this buffer in chunks from HES. Hence to avoid a situation wherein RMM requests an earlier chunk (which TF-A may have discarded as part of RMM consuming it), and forcing TF-A to buffer the whole platform token within EL3, it would be better to avoid the possibility for RMM to ask for previous chunks or even fast forward to future.",
      "parentUuid": "1b879776_876042d7",
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "55cb93a0_4f6b84ba",
        "filename": "lib/rmm_el3_ifc/src/rmm_el3_runtime.c",
        "patchSetId": 2
      },
      "lineNbr": 77,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-17T21:28:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "917953bb_bdcd8128",
      "revId": "ea91dcd50f7708974ea28fb78ee30bda9e54c172",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}