{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e476c12a_19877cd1",
        "filename": "drivers/pcie_tdi/src/include/pcie_tdi_private.h",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1001371
      },
      "writtenOn": "2024-07-05T09:04:59Z",
      "side": 1,
      "message": "TDI is typically used to refer to an instance of a physical device. But most of the parameters here are for the whole physical device. Sure enough that a TDI can be a PF or VF, may be the naming is confusing.\n\nAlso if it were to represent the pdev, where are the address association registers ?",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99dc4833_40505078",
        "filename": "drivers/pcie_tdi/src/include/pcie_tdi_private.h",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-08T22:21:39Z",
      "side": 1,
      "message": "also some of it seems like a repeat of what is in pdev..",
      "parentUuid": "e476c12a_19877cd1",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78f8a92e_8e9789e2",
        "filename": "drivers/pcie_tdi/src/include/pcie_tdi_private.h",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-07-09T18:05:43Z",
      "side": 1,
      "message": "@Yousuf\n\u003e TDI is typically used to refer to an instance of a physical device. \n\nYes, it can refer a PF or VF. But w.r.t current spec the init/connect/ioctl will be called only using a PDEV handle so the underlying device is always a PF.\n\nMay be later when VF can have a seperate connection to a device, this will change. And at that time we can introduce a flag to mentioned if this TDI is a VF or PF. Correct me if this is wrong. And also if there are any VF specific SMMU init needs to be done we handle it later. Current assumption for phase1 is the TDI is treated as a whole device (like passthrough).\n\n\u003e Also if it were to represent the pdev, where are the address association registers ?\n\nSure, that is missed out. I will add it.\n\n\n@Raghu\n\n\u003e also some of it seems like a repeat of what is in pdev..\n\nthese fields are in pdev_params that are passed during init and not in pdev. let me know which part of the code you are referring?",
      "parentUuid": "99dc4833_40505078",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b50d894_25c38dee",
        "filename": "drivers/pcie_tdi/src/include/pcie_tdi_private.h",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-09T20:25:31Z",
      "side": 1,
      "message": "i dont see why we need this level of indirection, the RMM spec already has data structures to abstract PFs/VFs so yet another layer of indirection seems unnecessary.\nAs for structure repetition, Why dont we just use the RmmPdev type from the spec? that already has device classes etc.",
      "parentUuid": "78f8a92e_8e9789e2",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3032c9a_192b7389",
        "filename": "drivers/pcie_tdi/src/include/pcie_tdi_private.h",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-07-11T14:39:53Z",
      "side": 1,
      "message": "Looks like I didn\u0027t get your question correct. Responding to this query\n\u003e also some of it seems like a repeat of what is in pdev..\n\nThis pcie_tdi is part of pdev and struct fields are not duplicated. I can\u0027t directly use the rmi_pdev_params as this struct has padding with 4k size. So these are copied to pdev.__dev_context (pcie_tdi) struct.\n\nAnd regarding indirection, the reason for doing this is to isolate device specific stuff like SPDM, IDE_KM, TDISP, IMPDEF Arm root port programming from runtime/rmi/da.c. There are many ways to do this. This is a minimal re-direction based on alp6 spec pdev.cls\u003dPCIE field. There are plans to add more device types, and with new spec alp7 the pdev.cls is removed and replaced with pdev.flags that could have [SPDM | \u003cdifferent types of IDE selection\u003e]. This pdev.flags represents various device configuration options. So this re-direction layer will also change as pdev.cls is removed. For now the plan is to add functionality like cert retrieval, secure session establishment, and implement spdm_get_measurement. And I will re-visit this redirection layer soon based on the new spec update.",
      "parentUuid": "4b50d894_25c38dee",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29067e17_b50a8ed0",
        "filename": "plat/common/src/plat_common_init.c",
        "patchSetId": 2
      },
      "lineNbr": 196,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-08T22:21:39Z",
      "side": 1,
      "message": "there is no way at boot, yo ucan know what devices aer present in the system. This has to happen at runtime and cannot happen during rmm init..",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa3d8dc1_c304a0a7",
        "filename": "plat/common/src/plat_common_init.c",
        "patchSetId": 2
      },
      "lineNbr": 196,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-07-09T18:05:43Z",
      "side": 1,
      "message": "\u003e there is no way at boot, yo ucan know what devices aer present in the system. ...\n\n\nRMM doesn\u0027t know if any TDISP capable device exist during boot time or runtime. This driver must be seen as an interface driver that registers different type of device classes supported by the RMM spec with the runtime component of RMM.\nI initial had these changes in lib folder, then moved to over here as this provides device like functionality like connect, sending/receving device commands. So at RMM init time this registers the device class with DA interfce layer. I can rename the driver name or it location based on any further comments.\n\nOnly during PDEV create RMM will have pdev_id (bdf for PCIe TDI) passed from Host. And even during that time RMM relies on NS host that it had actually passed a valid PCIe TDI with DOE/IDE_KM/TDISP capabilities.",
      "parentUuid": "29067e17_b50a8ed0",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e0eb074_adf5d160",
        "filename": "plat/common/src/plat_common_init.c",
        "patchSetId": 2
      },
      "lineNbr": 196,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-09T20:25:31Z",
      "side": 1,
      "message": "Perhaps this is a naming issue then. You are really registering a driver here for a device class, not a device. I dont see why you need that level of indirection, everything is statically linked anyway, you might as well call those APIs using a public header sicne for a given TDISP device, what we do in the RMM is device unique and not common.\nThe RMM spec already has sufficient abstractions and data structures so im not sure why we need another layer of indirection. What does it buy?",
      "parentUuid": "fa3d8dc1_c304a0a7",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fc7dc6b_7e53b935",
        "filename": "plat/common/src/plat_common_init.c",
        "patchSetId": 2
      },
      "lineNbr": 196,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2024-07-11T14:39:53Z",
      "side": 1,
      "message": "Agree, the name can be changed to driver or can be moved to lib directory as RMM doesn\u0027t probe any device. As mentioned earlier in the previous comment this naming also needs some change with the specification dropping pdev.cls. Initial assumption was for every device class there will class specific device operations.",
      "parentUuid": "4e0eb074_adf5d160",
      "revId": "db78f94854f14bd127fd6d891541b02b6870eeca",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}