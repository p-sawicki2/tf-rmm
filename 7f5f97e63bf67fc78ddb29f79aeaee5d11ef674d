{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "02e2d9c0_7f85a21a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "The params were not correctly communicated by me.  I have clarified.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de3e7c43_baf930ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:58:52Z",
      "side": 1,
      "message": "After giving it some thought, this sequence is  also valid:\n\n1. EL3 returns token_hunk_len as 0 and says remaining_len is x bytes  (where x !\u003d 0). This allows RMM to poll on EL3 in case the EL3 decides to implement a non-blocking call.\n\n2. If remaining_len is allowed to change during the course of hunk retrieval. This allows flexibility would be good wherein EL3 itself is not sure about the total size of token and needs the HES to reply to figure this out. \n\nOnce we have a working prototype of this interface, this document would also need suitable modification : https://trustedfirmware-a.readthedocs.io/en/latest/components/rmm-el3-comms-spec.html#rmm-attest-get-plat-token-command",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98ba0f5c_2dce2f5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2024-07-18T19:09:27Z",
      "side": 1,
      "message": "AFAICT, this approach implies that RMM-EL3 buffer should stay at 4KB. This in turn introduces a memcpy in EL3 to copy the token to the shared buffer in pieces.\n\nA faster approach would be to increase the RMM-EL3 shared buffer to eliminate the extra memcpy. For platforms that are capable of using a larger size, it would be beneficial.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35f86493_270fe3ee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-19T10:08:16Z",
      "side": 1,
      "message": "There are several considerations to the approach: \n\n1. The RMM-EL3 buffer size is 4KB and it is a single buffer for all CPUs. This is not scalable for system wherein the buffer may be used frequently (eg : Realm token signing by HES). Also this is not an ideal design for NUMA. Hence we would like to move to per-CPU buffer for RMM-EL3 comms. Not increasing the size of buffer will save memory needed in this scheme.\n\n\n2. Being an interface buffer between EL3 and RMM, it will help to standardize the interface thus removing platform specific sizes for buffer used for comms. Also removing the platform dependancy on the buffer size will enable RMM to do buffer management and mapping in S1 TT within RMM generically.\n\n3. The platform token is currently only retrieved during cold boot. The memcpy overhead is the same (it is just broken to multiple parts). An additional SMC is involved but being cold boot this overhead is not an issue. (perhaps for Realm key refresh in future this may be done at runtime, but this will be very infrequent), \n\n4. The current mechanism provides the flexibility to implement a streaming type of interface (rather than blocking call). Consider a situation when a large platform token needs to be retrieved from HES. This interface allows to be non-blocking and return early to implement a \"polling\" loop thus allowing EL3 to return early to RMM if HES is busy. Also if the size of EL3-HES buffer is not large enough to accomodate the platform token , it is likely that EL3 will need to retrieve the token in streaming fashion from HES. This interface maps neatly into such a HES comms scheme as well.\n \nAnd hence we have gone with such a design.",
      "parentUuid": "98ba0f5c_2dce2f5d",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94dda02e_35b3c2e6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2024-07-19T15:00:52Z",
      "side": 1,
      "message": "This design choice makes several assumptions.\n\n1. The platform does not have enough memory for a larger per-PE RMM-EL3 shared buffer.\n2. The HES cannot write the entire token to memory in one go.\n3. The HES does not have access to DRAM and so the memory area for saving the token is limited.\n\nAll these assumptions do not apply to all platforms.\n\nThe available memory and HES performance are platform specific and we cannot standardize them. With several calls we add SMC turnaround time to the use case, which can be avoided IMO.\n\nI dont understand how adding smaller shared memory can allow the RMM to poll. We can add polling irrespective of the size. If the HES provides an interrupt, EL3 can always return to RMM.\n\nI think the design considers slower HES, platforms with smaller DRAM. But it should also consider platforms with faster HES and less/no memory restrictions.",
      "parentUuid": "35f86493_270fe3ee",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f132bd2a_f6e7b555",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-19T15:39:37Z",
      "side": 1,
      "message": "\u003e The platform does not have enough memory for a larger per-PE RMM-EL3 shared buffer.\n\nIt doesn\u0027t make this assumption, but it saves memory used for RMM-EL3 buffers.\n\n\u003e The HES cannot write the entire token to memory in one go.\n\nYes, it caters for the possibility.\n\n\u003e The HES does not have access to DRAM and so the memory area for saving the token is limited.\n\nIt doesn\u0027t make that assumption. It caters for the possibility that HES will have a Queue mechanism for communication with EL3 and the individual Queue element size may be smaller that the platform token. Note that HES is not allowed to access any domain other than Root (EL3) domain as a security principle. El3-RMM shared buffer is in Realm domain. Also see last comment.\n\n\u003e The available memory and HES performance are platform specific and we cannot standardize them.\n\nThe EL3-RMM interface is standardized with TF-A(and TF-RMM) and is maintained by the spec : https://trustedfirmware-a.readthedocs.io/en/latest/components/rmm-el3-comms-spec.html\n\nThe EL3-RMM buffer comms buffer is not tied to HES.\n\n\u003e I dont understand how adding smaller shared memory can allow the RMM to poll. We can add polling irrespective of the size. If the HES provides an interrupt, EL3 can always return to RMM\n\nThe semantics of the call is such that the entire token need not be returned in one go. It is legal for EL3 to return \"token_hunk_len\" as 0 while keeping the remaining_len as size of token thus allowing it to poll.\n\n\u003e I think the design considers slower HES, platforms with smaller DRAM. But it should also consider platforms with faster HES and less/no memory restrictions.\n\nAn additional SMC is required for a token upto 8KB. The flexibility offered by the semantics and maintainability of having constant RMM-EL3 buffer over weighs the SMC latency concern. Any HES can be overwhelmed by (100+) AP CPUs which can pump requests at a very high rate via EL3. Hence typically EL3 will implement some rate limit logic/fairness logic to prevent DoS to HES.\n\n\u003e I think the design considers slower HES, platforms with smaller DRAM. But it should also consider platforms with faster HES and less/no memory restrictions.\n\nNot sure if HES is allowed to touch EL3-MM shared buffer in your case, As a security guideline, HES is not allowed to write to Realm memory directly (ie. EL3-RMM shared buffer). So effectively HES needs to communicate with EL3 and if the HES comms are via EL3 buffers in SRAM, it becomes a scarce resource. El3 can always have DDR carveouts, but wanted to point out that the comms can be via SRAM as well.",
      "parentUuid": "94dda02e_35b3c2e6",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08a4e0d5_191f9c24",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "02e2d9c0_7f85a21a",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "09c33606_bbcafe48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "de3e7c43_baf930ef",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9471764e_7cdfeda2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-09-10T21:48:33Z",
      "side": 1,
      "message": "@Soby, @Varun, \n\nDo you need to discuss this any further, or can I close this discussion?\n\nThanks :)",
      "parentUuid": "f132bd2a_f6e7b555",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a3fd713_a5b45baa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-09-11T10:31:25Z",
      "side": 1,
      "message": "Can be closed.",
      "parentUuid": "9471764e_7cdfeda2",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a297d37_9634bb95",
        "filename": "lib/attestation/CMakeLists.txt",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "keep the original as default. And then override it for host_build platform.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "105f282c_34e17790",
        "filename": "lib/attestation/CMakeLists.txt",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8a297d37_9634bb95",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c4348b5_ee49ec81",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 231,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "this is the length of the current hunk/chuck returned. so perhaps this should be called token_hunk_len.\n\nso the check should probably be (offset + token_hunk_len + remaining_len) \u003e RMM_PLAT_TOKEN_MAX_SIZE",
      "range": {
        "startLine": 231,
        "startChar": 6,
        "endLine": 231,
        "endChar": 25
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4bc47b74_0c06138f",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 231,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3c4348b5_ee49ec81",
      "range": {
        "startLine": 231,
        "startChar": 6,
        "endLine": 231,
        "endChar": 25
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "307a9657_56272eaa",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 240,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "this should just be `token_hunk_len`",
      "range": {
        "startLine": 240,
        "startChar": 6,
        "endLine": 240,
        "endChar": 51
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7320bd06_2f0a00ea",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 240,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "307a9657_56272eaa",
      "range": {
        "startLine": 240,
        "startChar": 6,
        "endLine": 240,
        "endChar": 51
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6572726_3cfcb478",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 242,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "offset +\u003d token_hunk_len",
      "range": {
        "startLine": 242,
        "startChar": 11,
        "endLine": 242,
        "endChar": 45
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04a5968b_09a01ede",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 242,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f6572726_3cfcb478",
      "range": {
        "startLine": 242,
        "startChar": 11,
        "endLine": 242,
        "endChar": 45
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54bd9d5e_102c2228",
        "filename": "plat/host/common/src/host_harness_cmn.c",
        "patchSetId": 3
      },
      "lineNbr": 103,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:53:20Z",
      "side": 1,
      "message": "Is the added byte added a valid token ? \n\nIf not, this change can be done locally to test the changes and then lets stick to original token.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04855508_4d555de7",
        "filename": "plat/host/common/src/host_harness_cmn.c",
        "patchSetId": 3
      },
      "lineNbr": 103,
      "author": {
        "id": 1000750
      },
      "writtenOn": "2024-07-22T20:37:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "54bd9d5e_102c2228",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}