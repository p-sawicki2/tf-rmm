{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "02e2d9c0_7f85a21a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "The params were not correctly communicated by me.  I have clarified.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de3e7c43_baf930ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:58:52Z",
      "side": 1,
      "message": "After giving it some thought, this sequence is  also valid:\n\n1. EL3 returns token_hunk_len as 0 and says remaining_len is x bytes  (where x !\u003d 0). This allows RMM to poll on EL3 in case the EL3 decides to implement a non-blocking call.\n\n2. If remaining_len is allowed to change during the course of hunk retrieval. This allows flexibility would be good wherein EL3 itself is not sure about the total size of token and needs the HES to reply to figure this out. \n\nOnce we have a working prototype of this interface, this document would also need suitable modification : https://trustedfirmware-a.readthedocs.io/en/latest/components/rmm-el3-comms-spec.html#rmm-attest-get-plat-token-command",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98ba0f5c_2dce2f5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2024-07-18T19:09:27Z",
      "side": 1,
      "message": "AFAICT, this approach implies that RMM-EL3 buffer should stay at 4KB. This in turn introduces a memcpy in EL3 to copy the token to the shared buffer in pieces.\n\nA faster approach would be to increase the RMM-EL3 shared buffer to eliminate the extra memcpy. For platforms that are capable of using a larger size, it would be beneficial.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a297d37_9634bb95",
        "filename": "lib/attestation/CMakeLists.txt",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "keep the original as default. And then override it for host_build platform.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c4348b5_ee49ec81",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 231,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "this is the length of the current hunk/chuck returned. so perhaps this should be called token_hunk_len.\n\nso the check should probably be (offset + token_hunk_len + remaining_len) \u003e RMM_PLAT_TOKEN_MAX_SIZE",
      "range": {
        "startLine": 231,
        "startChar": 6,
        "endLine": 231,
        "endChar": 25
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "307a9657_56272eaa",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 240,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "this should just be `token_hunk_len`",
      "range": {
        "startLine": 240,
        "startChar": 6,
        "endLine": 240,
        "endChar": 51
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6572726_3cfcb478",
        "filename": "lib/attestation/src/attestation_key.c",
        "patchSetId": 3
      },
      "lineNbr": 242,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:51:52Z",
      "side": 1,
      "message": "offset +\u003d token_hunk_len",
      "range": {
        "startLine": 242,
        "startChar": 11,
        "endLine": 242,
        "endChar": 45
      },
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54bd9d5e_102c2228",
        "filename": "plat/host/common/src/host_harness_cmn.c",
        "patchSetId": 3
      },
      "lineNbr": 103,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T12:53:20Z",
      "side": 1,
      "message": "Is the added byte added a valid token ? \n\nIf not, this change can be done locally to test the changes and then lets stick to original token.",
      "revId": "7f5f97e63bf67fc78ddb29f79aeaee5d11ef674d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}