.. SPDX-License-Identifier: BSD-3-Clause
.. SPDX-FileCopyrightText: Copyright TF-RMM Contributors.

*******
Fuzzing
*******

Configuration
=============

This fuzzing setting uses `AFL++`_. AFL++ provides many modes, and we are using
`alf-clang-lto`_ and the `persistent mode`_ for the best performance. The source
code is compiled with the compiler ``alf-clang-lto``, that (1) analyses and
instruments the source code for better fuzzing result, better coverage, for
example, and (2) performs link-time optimization (LTO) on the final executable.
At the time we are writing this readme, ``alf-clang-lto`` only exists in the
AFL++ for Linux. The persistent mode, meanwhile, fuzzes the target (binary)
multiple times in a single fork, which accelerates the fuzzing process. We
observe the speed-up is around 3-5x for our persistent mode setup to fuzz RMM.

Strategy
========

Although fuzzing can be applied directly to any binary, treating it as a
'black-box', we adopt more 'white-box' method: compiling the source code with
the AFL++-altered compiler ``afl-clang-lto`` and providing an separate entry
point to the fuzzing engine. This enables us tailor the fuzzing and achieve
better result.

In short, our strategy can be summarised as: given an arbitrary machine state,
and given a certain numbers of RMM interface calls (1) we expect no program
crash and (2) the machine state evolves as expected from the specification. The
first goal (1) is relatively straightforward and is now stable, but the second
goal (2) is being actively developed. The machine state contains:

* all granule data, ``unsigned char granules_buffer[HOST_MEM_SIZE]
  __aligned(GRANULE_SIZE);``, originally declared in
  ``plat/host/common/src/host_utils.c``, 
* all granule meta-data, ``struct
  granule granules[RMM_MAX_GRANULES];``, originally declared in
  ``lib/granule/src/granule.c``.

The fuzzing entry point, ``plat/host/host_fuzz/src/host_setup.c``, populates the
two data structs with the fuzzing input generated by the fuzzer, in the
``iteration_init`` function. Given the initial machine state, the function
``execute`` extracts the predefined number of RMI interface calls' parameters
from the fuzzing input, and calls them (the number of calls is defined by macro
``FUZZ_COMMAND_COUNT``). In fact, the function ``execute`` in
``plat/host/host_fuzz/src/host_setup.c`` reads random byte from the fuzzing
engine, feeds them to register ``X0`` to ``X6`` and calls the handler function
``handle_ns_smc``.

We recommend using persistent mode, which means compiling with flag
``PERSISTENT_MODE``. However, when crashes are found, and users want to check
and debug the cause, compiling with non-persistent mode allows the binary read
an input, i.e., a file, and then execute the crashing cases. In the persistent
mode setup, we only initialise the RMM global state once, via ``init`` function,
before the fuzzing loop. Note that ``init`` must be called before
``_AFL_INIT()``, more details on using persistent mode can be found in link:
`persistent mode`_.

Generate corpus
---------------

AFL++ needs some initial inputs, or corpus. Ideally, we should provide some
meaningful corpus as the 'seed' for fuzzing. However, for now, we simply
generate one corpus with 'almost' random bytes, except the register ``X0``,
which indicates the RMM interface FID. The value of ``X0`` is not picked from
the full range of 64-bit integer but from a range that is slighly wider that the
range of the existing RMI interface FIDs as defined by the RMM specification;
the fuzzing ranges are control by variables ``FID_BEGIN`` and ``FID_END``. The
corpus is automatically generated via a python script,
``tools/fuzz/python/generate_corpus.py``.

This corpus generation can be improve to provide better result. One idea is
scripting a common scenario of RMM consecutive calls.

Custom mutator
--------------

AFL++ allows users provide `custom mutator`_, that is, how random inputs are
generated. We use this mechanism to restrict the range of register ``X0``
between ``FID_BEGIN`` and ``FID_END``, the same range to the fuzzing corpus.
Details can be found at python script ``tools/fuzz/python/mutate.py``.

Separately, we ask fuzzing engine only generate fixed-size inputs, which are
meaningful for the fuzzing front end. We achieve this by passing the size bounds
to the AFL directly, ``-g ${FUZZ_BUFF_SIZE} -G ${FUZZ_BUFF_SIZE}``, where
``-g`` and ``-G`` specify lower and upper bounds respectively.

How to use
==========

Run the following command:

.. code-block:: bash

    cmake -DRMM_CONFIG=host_defcfg \
          -DHOST_VARIANT=host_fuzz \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_COMPILER=/usr/local/bin/afl-clang-lto \
          -DCMAKE_AR=/usr/bin/llvm-ar \
          -DCMAKE_LINKER=/usr/local/bin/afl-ld-lto \
          -DCMAKE_C_FLAGS="-DVERIFICATION_FLAG -DPERSISTENT_MODE" \
          -S ${ROOT_OF_RMM} \
          -B ${TARGET_DIR}

The values for ``RMM_CONFIG`` and ``HOST_VARIANT`` ensure that we are compiling
for host mode of RMM and for fuzzing, respectively. Since fuzzing relies on
explicit ``assert``, which checks property and crashes the program if fails, we
must compile with ``debug`` mode. We need to compile the source code and link
the binary with AFL++-altered compiler, and therefore, we have to provide the
correct paths to ``afl-clang-lto``, ``llvm-ar`` and ``afl-ld-lto`` when run
``cmake``. The main challenge of fuzzing is the searching space. We config the
RMM with smaller machine state defined by ``RMM_MAX_GRANULES`` and
``HOST_MEM_SIZE``, which are specified in the
``plat/host/host_fuzz/CMakeLists.txt``. The latter variable configuration can,
in fact, derive from the former, ``HOST_MEM_SIZE = RMM_MAX_GRANULES *
GRANULE_SIZE``, where ``GRANULE_SIZE`` is typically 4k. Then, our fuzzing setup
needs being able to access some internal data structures representing the
machine state, which is done by switch on ``VERIFICATION_FLAG`` flag. Further,
flag ``PERSISTENT_MODE`` enables the persistent setup in our fuzzing front end.
Last, ``${ROOT_OF_RMM}`` should be the root directory of RMM source code, and
``${TARGET_DIR}`` should be the target directory for ``cmake`` result.

After the ``cmake``, we should run

.. code-block:: bash

    cmake --build ${ROOT_OF_RMM} -- run-fuzzer

Or we can manually run ``make``,

.. code-block:: bash

    make -C ${ROOT_OF_RMM} run-fuzzer

which actually compiles the source code and then runs the fuzzing.

We recommend to run fuzzing in the background, for example, with the help of
``screen`` command in Linux. We are actively improving the fuzzing, for example,

* improve the custom mutation,
* apply suggestion in `fuzzing in depth`_.

AFL Command line
================

The fuzzing configuration can be found in ``tools/fuzz/CMakeLists.txt`` file
in the custom target ``run-fuzzer``.
We set ``AFL_AUTORESUME`` resuming previous fuzzing instance if exists.
Variables ``PYTHONPATH`` and ``AFL_PYTHON_MODULE`` config the custom mutator to
AFL++. Parameters ``-i`` and ``-o`` specify the input/corpus directory and
output directory. Then we add several parameters to get better performance:

* ``-g`` and ``-G``, as mentioned before, specify the lower and upper bound of
  random inputs,
* ``-a binary`` indicates input is binary data,
* ``-P exploit`` requests fuzzing engine to put focus on exploit ``assert``
  failure.

After ``--`` is the target binary path,
``${CMAKE_BINARY_DIR}/$<CONFIG>/rmm.elf`` and last, symbols ``@@`` specifies
the target program takes input from a file.

-----

.. _AFL++: https://github.com/AFLplusplus/AFLplusplus
.. _alf-clang-lto: https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.lto.md
.. _persistent mode: https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md
.. _custom mutator: https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/custom_mutators.md
.. _fuzzing in depth: https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md
