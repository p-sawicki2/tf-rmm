{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "46e31893_a13555fb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-07-18T13:38:27Z",
      "side": 1,
      "message": "Please provide more details why this change is needed.",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09940c99_94cdcd82",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T13:49:44Z",
      "side": 1,
      "message": "Sorry, I just remembered why we have the unusual way to allocate aux_data pages. It is easier to illustrate this via an example :\n\nIt is possible for NS_HOST to not not enable SVE and PMU support for a Realm. In such a scenario, RMM could return a lower REC_AUX_COUNT when RMI_REC_AUX_COUNT is called by Host. This means, Host could allocate lower count of Aux pages when creating a REC. \n\nCurrently we dont do this optimization in RMM and hence it is not clear from the implementation why the strange way to allocate AUX pages.",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7efaba17_56cd751a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2024-07-19T07:15:44Z",
      "side": 1,
      "message": "Hmm, Ok. Then I better abandon this review.",
      "parentUuid": "09940c99_94cdcd82",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ffe86b9_e78daae3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-19T09:22:47Z",
      "side": 1,
      "message": "There is another way to think about this. For each combination  declare a separate struct type. then define another struct type with the first field indicating the type of object and pointer to aux data.\n\nWhen the realm is created, depending on the capabilities selected for the realm , choose the type of object and depending on this type, the pointer needs to be typecast to the right structure and used. \n\nThen again it sounds very difficult to reason about correctness. But the patch has highlighted an important refactoring needed. We need a small framework to manage this properly. created a backlog ticket: https://jira.arm.com/browse/GENFW-9253",
      "parentUuid": "7efaba17_56cd751a",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0dc28e16_c80cba0d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-19T09:24:08Z",
      "side": 1,
      "message": "This patch can be abandoned",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d16ed01c_8137fbb7",
        "filename": "runtime/include/rec.h",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-07-18T13:38:27Z",
      "side": 1,
      "message": "add extra tab to align",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6af9752_8c045b18",
        "filename": "runtime/include/rec.h",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-18T13:49:44Z",
      "side": 1,
      "message": "may not be needed for CBMC build.",
      "range": {
        "startLine": 58,
        "startChar": 8,
        "endLine": 58,
        "endChar": 24
      },
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78f2a70d_8415ca5a",
        "filename": "runtime/include/rec.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-07-18T13:38:27Z",
      "side": 1,
      "message": "pointers to -\u003e structures of",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd52abaa_5e05d67e",
        "filename": "runtime/rmi/rec.c",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-07-18T13:43:59Z",
      "side": 1,
      "message": "This causes misra_c_2012_rule_10_1_violation, because all operands are long, but macro uses 1 insead of 1L. We can modify macro to use 1UL \u0026 remove casts in REC_NUM_PAGES.",
      "revId": "c505953be44877f1db00e1e6475f54501460f2b7",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}