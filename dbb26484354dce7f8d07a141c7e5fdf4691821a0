{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bea081f3_ad3adbbd",
        "filename": "lib/attestation/src/attestation_token.c",
        "patchSetId": 3
      },
      "lineNbr": 341,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2024-06-24T09:46:34Z",
      "side": 1,
      "message": "This should be an assert instead. Or are there cases when it is function is expected to be called with invalid ctx?",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 341,
        "endChar": 2
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8629ae87_a68f5c15",
        "filename": "lib/attestation/src/attestation_token.c",
        "patchSetId": 3
      },
      "lineNbr": 341,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-26T01:04:49Z",
      "side": 1,
      "message": "this is a public function, and we shouldnt be using asserts to check validity of parameters no?\nIf this was a static function, an assert would be appropriate.",
      "parentUuid": "bea081f3_ad3adbbd",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 341,
        "endChar": 2
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "680aeed6_83879d42",
        "filename": "lib/attestation/src/attestation_token.c",
        "patchSetId": 3
      },
      "lineNbr": 341,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2024-06-27T08:53:57Z",
      "side": 1,
      "message": "Your reasoning makes sense. However I think that calling this function with `ctx \u003d\u003d NULL` is probably a mistake by the user of the library. So I think it would be reasonable for this function to expect a valid `ctx`, and not silently ignore a NULL context.\n\nSo if using assert is not an option, and we want to sanitize the incoming parameters as this function is an entry point to the library, then the proper solution would be I think to have a return value for this function, and check at the calling locations whether the init was successful.",
      "parentUuid": "8629ae87_a68f5c15",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 341,
        "endChar": 2
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdfa61a5_cb9c1a31",
        "filename": "lib/attestation/src/attestation_token.c",
        "patchSetId": 3
      },
      "lineNbr": 341,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-29T04:45:07Z",
      "side": 1,
      "message": "sure return code it is.",
      "parentUuid": "680aeed6_83879d42",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 341,
        "endChar": 2
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69b18bd9_212e9414",
        "filename": "lib/attestation/src/attestation_token.c",
        "patchSetId": 3
      },
      "lineNbr": 341,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-17T16:59:40Z",
      "side": 1,
      "message": "The approach usually taken in RMM is to use assert() to catch programming errors when the callers and the arguments are within the trust boundary.\n\nSince `ctx` and the caller to this function is entirely within the RMM trust boundary, an assert will suffice to enforce the pre-condition for this API.",
      "parentUuid": "cdfa61a5_cb9c1a31",
      "range": {
        "startLine": 339,
        "startChar": 0,
        "endLine": 341,
        "endChar": 2
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a8c3f88_8c388979",
        "filename": "runtime/rsi/realm_attest.c",
        "patchSetId": 3
      },
      "lineNbr": 159,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2024-06-24T09:46:34Z",
      "side": 1,
      "message": "Why is it necessary to call `attest_token_ctx_init` here? Setting ATTEST_SIGN_NOT_STARTED in the state should prevent the state machine getting here without calling `handle_rsi_attest_token_init`, which calls `attest_token_ctx_init`.",
      "range": {
        "startLine": 159,
        "startChar": 2,
        "endLine": 159,
        "endChar": 80
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fd7c4a7_81cad9a7",
        "filename": "runtime/rsi/realm_attest.c",
        "patchSetId": 3
      },
      "lineNbr": 159,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-26T01:04:49Z",
      "side": 1,
      "message": "calling attest_token_init for consistency. All changes to state to ATTEST_SIGN_NOT_STARTED would be made via that function call.",
      "parentUuid": "8a8c3f88_8c388979",
      "range": {
        "startLine": 159,
        "startChar": 2,
        "endLine": 159,
        "endChar": 80
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2542e1d_9a5a7851",
        "filename": "runtime/rsi/realm_attest.c",
        "patchSetId": 3
      },
      "lineNbr": 159,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2024-06-27T08:53:57Z",
      "side": 1,
      "message": "I don\u0027t think it is necessary to be consistent with this. The `state` field is part of the state machine management, while the rest of the structure is the working area of the signing process. \n\nSo those are logically two different things. Maybe it is not the most convenient thing that the state is part of the context structure, but it makes it easier passing around in functions.",
      "parentUuid": "6fd7c4a7_81cad9a7",
      "range": {
        "startLine": 159,
        "startChar": 2,
        "endLine": 159,
        "endChar": 80
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bd3464f_d042d47a",
        "filename": "runtime/rsi/realm_attest.c",
        "patchSetId": 3
      },
      "lineNbr": 159,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-29T04:45:07Z",
      "side": 1,
      "message": "I think the way the context is written already is not right, you really want accessors to those fields. why is run time code touching fields of context used by attestation lib? \nsure we’ve made that choice but don’t think we need to perpetuate it and we can start moving things to accessor functions. \nif you insist we pass around and modify state variables across code, that’s fine, I don’t follow the logic on how that is more maintainable. \nfor example I can really avoid the init function and call the t_code function directly in runtime and functionally no different but now we’d have to call that in an ifdef every where the state changes. \nimagine a new rmm spec with more states for attestation, and depending on what the new state is we might have to call the init on the t_cose state. \nthis may all be moot if we move to hook via mbedtls but worth keeping in mind if I still need to init an mbedtls adapter context",
      "parentUuid": "f2542e1d_9a5a7851",
      "range": {
        "startLine": 159,
        "startChar": 2,
        "endLine": 159,
        "endChar": 80
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f7c23b5_51abad00",
        "filename": "runtime/rsi/realm_attest.c",
        "patchSetId": 3
      },
      "lineNbr": 159,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2024-07-03T12:05:39Z",
      "side": 1,
      "message": "Thanks for the explanation (and please forgive if I still didn\u0027t get your point completely). My concern was calling memset on the whole context even if it is not necessary. But your point point about directly accessing context members all around the code makes complete sense.\n\nSo how about defining two operations, resetting the attestation state, and initializing the context. For example:\n\n    int attest_token_reset_state(struct token_sign_cntxt *ctx)\n    {\n        if (!ctx) {\n            return -EINVAL;\n        }\n        ctx-\u003estate \u003d ATTEST_SIGN_NOT_STARTED;\n    }\n\n    int attest_token_ctx_init(struct token_sign_cntxt *ctx, uintptr_t granule_addr)\n    {\n        if (!ctx) {\n            return -EINVAL;\n        }\n\n        (void)memset(ctx, 0, sizeof(*ctx));\n        (void)attest_token_reset_state(ctx);\n\n    #if RMM_ATTESTATION_USE_HES\n        t_cose_crypto_hes_ctx_init(\u0026ctx-\u003ectx.crypto_ctx, granule_addr);\n    #endif\n    }",
      "parentUuid": "7bd3464f_d042d47a",
      "range": {
        "startLine": 159,
        "startChar": 2,
        "endLine": 159,
        "endChar": 80
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c677040_db67fa62",
        "filename": "runtime/rsi/realm_attest.c",
        "patchSetId": 3
      },
      "lineNbr": 159,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-16T15:44:33Z",
      "side": 1,
      "message": "ack, let me make this change as suggested.",
      "parentUuid": "5f7c23b5_51abad00",
      "range": {
        "startLine": 159,
        "startChar": 2,
        "endLine": 159,
        "endChar": 80
      },
      "revId": "dbb26484354dce7f8d07a141c7e5fdf4691821a0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}