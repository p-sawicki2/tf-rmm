{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fa26f352_0a8d8977",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 28,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-21T06:44:03Z",
      "side": 1,
      "message": "The EL3-RMM interface itself is versioned and binds all the structures and the sizes. Now since this is an optional interface, it does have a case to have separate versioning. \n\nNeed to think further :\n1. Will all optional EL3-RMM SMCs need to keep its own versioning ? If that is the case, will it be problematic for RMM to work out compatibility with EL3 firmware.\n\n2. The RMM-EL3 FID space is limited. If we do get more of these optional SMCs in future, do we need a more optimal FID strategy for optional SMCs ?",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 28,
        "endChar": 44
      },
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ca08112_1726410b",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 28,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-21T22:25:38Z",
      "side": 1,
      "message": "Agree, i dont think the versioning is required, given we removed queining from RMM. This was for teh case where queining is done in RMM and El3 is a pass through, then the interface is between RMM and HES, which definitely needs to be versioned.\nI will push a patch to remove.\n#2 is a general problem and fixing that can be independent of this i think. Happy to brainstorm separately on that, example could reserved range for optional SMCs or have a fixed SMC that can return back moving SMC FID for a \"capability\" or try/fail SMC with flags that abstract functionality.",
      "parentUuid": "fa26f352_0a8d8977",
      "range": {
        "startLine": 27,
        "startChar": 0,
        "endLine": 28,
        "endChar": 44
      },
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5f9754d_62d1f94f",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 89,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-21T06:44:03Z",
      "side": 1,
      "message": "Is this memset(0) of the remaining buffer needed ? I couldnt think of a specific problem if this is not done. My assumption is that EL3 will only read the specified size.\n\nIf at all this is needed, it may be faster to use `granule_memzero_mapped` on the buffer and then copy the request to it.",
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2d17e79_2f2d5bb9",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 89,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-21T22:25:38Z",
      "side": 1,
      "message": "cleanliness and defense in depth. The shared buffer could be used for other things and ideally EL3 shouldnt use those bytes but zeroing memory would be better in case it does. Happy to remove it.\nAlso left over from the days where we might want to extend this structure in the next version, but given this can be tied to the EL3-RMM interface version, we dont need it anymore.",
      "parentUuid": "b5f9754d_62d1f94f",
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee2d89ea_44a56cf9",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 143,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-21T06:44:03Z",
      "side": 1,
      "message": "should this be -EAGAIN  or another error to indicate EMPTY ?",
      "range": {
        "startLine": 143,
        "startChar": 13,
        "endLine": 143,
        "endChar": 19
      },
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96466f51_40eaf56f",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 143,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-21T22:25:38Z",
      "side": 1,
      "message": "see this comment and response: https://review.trustedfirmware.org/c/TF-RMM/tf-rmm/+/29291/3..10/runtime/core/hes_queue.c#b190\n\nWe dont need to differentiate EMPTY or try again in this interface since the function should allow to infer what it is. if EL3 is busy, it is busy and RMM trying to do anything to solve EL3/HES specific problems is not beneficial.",
      "parentUuid": "ee2d89ea_44a56cf9",
      "range": {
        "startLine": 143,
        "startChar": 13,
        "endLine": 143,
        "endChar": 19
      },
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ac1a6de_8d506287",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 158,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-21T06:44:03Z",
      "side": 1,
      "message": "These may need to be runtime checks at boot. But potentially both push and pull will need to be same version, so if push has not reported error, then it is unlikely pull will have different errors. \n\nneed to think further on versioning as aspects as mentioned above.",
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23043627_4d99a16b",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 158,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-21T22:25:38Z",
      "side": 1,
      "message": "will remove these fields, as discussed in other comments. left over from the days of RMM queuing requests.",
      "parentUuid": "5ac1a6de_8d506287",
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28324161_f16ef894",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 181,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-21T06:44:03Z",
      "side": 1,
      "message": "If the response corresponds to the current REC, is there a risk in double mapping AUX pages to 2 different VAs  (VA alias) ?\n\nIs there a way to detect whether the response is for a pending request by the current REC , using ticket number perhaps ?",
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da034841_06bc7927",
        "filename": "runtime/core/hes_queue.c",
        "patchSetId": 10
      },
      "lineNbr": 181,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-21T22:25:38Z",
      "side": 1,
      "message": "can you elaborate on why is it a \"risk\"? Mapping same PA with 2 VAs and same attributes is a valid way to access memory without issues.\nWe can detect if the REC is mapped using the ticket number but that seems somewhat hacky to identify the REC since the ticket number is to identify the request, not the REC itself. The rec_granule_addr uniquely identifies the REC itself.\nThe non-hacky way (other than mapping at different VA like this patch) to do it would be to have a way to identify if a slot in the slot buf (rec in this case) it currently in use and look up the granule that is mapped to the slot currently. or perhaps use address translation instruction at the REC VA to get back the PA and compare and then have an if else.\nYet another option, since this function is called from one and only one place, is to pass the current REC granule address as a parameter and skip the granule lock and map if it matches the response being processed. The granule lock is required to prevent it from being destroyed, but in the code path where this is called, we know for certain we have a ref count on the REC and it cannot be destroyed.\nI think the last option is worthwhile and easy to implement to get the benefit of the optimization.",
      "parentUuid": "28324161_f16ef894",
      "revId": "85f466873759ae48b432e8f97b80718b722e53f3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}