{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "06e38b33_1e38cd1b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-16T09:13:22Z",
      "side": 1,
      "message": "Thanks for the rework. Minor comments.",
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b471135d_04f1c94e",
        "filename": "docs/design/cold-and-warm-boot-design.rst",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-16T09:16:52Z",
      "side": 1,
      "message": "This clarification would be good.\n\n\"... on any data modified which is not part of per-CPU stack in RMM.\"",
      "range": {
        "startLine": 47,
        "startChar": 22,
        "endLine": 47,
        "endChar": 60
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c94a3b1a_e0825d4d",
        "filename": "docs/design/cold-and-warm-boot-design.rst",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-17T00:52:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b471135d_04f1c94e",
      "range": {
        "startLine": 47,
        "startChar": 22,
        "endLine": 47,
        "endChar": 60
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcb7d02f_e0375bc2",
        "filename": "docs/design/cold-and-warm-boot-design.rst",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-07-16T09:08:50Z",
      "side": 1,
      "message": "a function doesn\u0027t need to depend on...",
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18e0e7a4_a9d56395",
        "filename": "docs/design/cold-and-warm-boot-design.rst",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-17T00:52:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bcb7d02f_e0375bc2",
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fb02664_d7f6606e",
        "filename": "runtime/core/aarch64/head.S",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-16T09:13:22Z",
      "side": 1,
      "message": "The value of x0 will be fixed up during PIE fixup. Also here both cold and warm boots paths overlap thus executing this on warm boot paths as well. \n\nHence I think , this logic is better to run after PIE fixup. Can be after or before BSS memset.\n\nLine 110 should be a good place.",
      "range": {
        "startLine": 53,
        "startChar": 6,
        "endLine": 53,
        "endChar": 8
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d92177f4_acc0b4d1",
        "filename": "runtime/core/aarch64/head.S",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-17T00:52:19Z",
      "side": 1,
      "message": "can you elaborate why it is better? after your comment, i was thinking it MUST be done after reloc? rmm_base and rmm_end are link time addresses so if rmm gets relocated, we would be invalidating incorrect locations?\n\nagree 110 is a good place, i think the latest point it can be done is before xlat_enable_mmu_el2 since thats really when data caches are enabled, and until then we are \"safe\".",
      "parentUuid": "5fb02664_d7f6606e",
      "range": {
        "startLine": 53,
        "startChar": 6,
        "endLine": 53,
        "endChar": 8
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b46733f8_ac749f44",
        "filename": "runtime/core/aarch64/head.S",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-17T01:03:49Z",
      "side": 1,
      "message": "actually why does this not apply to warmboot? when EL3 on secondary cores boot up, again cache lines could be allocated, and when other cores access data on turning on MMU, they can access stale lines right?\nor is the assumption that secondary core wont write to any location? if yes, that seems like a flaky assumption?",
      "parentUuid": "d92177f4_acc0b4d1",
      "range": {
        "startLine": 53,
        "startChar": 6,
        "endLine": 53,
        "endChar": 8
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "467bf892_38a9cee3",
        "filename": "runtime/core/aarch64/head.S",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-17T09:19:12Z",
      "side": 1,
      "message": "\u003e can you elaborate why it is better? after your comment, i was thinking it MUST be done after reloc? rmm_base and rmm_end are link time addresses so if rmm gets relocated, we would be invalidating incorrect locations?\n\nrmm_base is 0x0 at link time and this will be fixed up after the PIE reloc fixups. Hence for the invalidations to act on the right addresses, this will need to be done after PIE fixup.\n\n\n\u003e actually why does this not apply to warmboot? when EL3 on secondary cores boot up, again cache lines could be allocated, and when other cores access data on turning on MMU, they can access stale lines right?\nor is the assumption that secondary core wont write to any location? if yes, that seems like a flaky assumption?\n\nThe data incoherency can happen if any secondary accesses data before its MMU is turned ON. We have the 2nd rule which says \"Any function in RMM which is invoked prior to MMU enable needs to perform CMOs on any data modified which is not part of the per-cpu stack in the RMM.\" \n\nBefore MMU on, The warm boot path should only write/modify per-cpu data for the corresponding CPU (and perform CMO). It can read data which is global but it should have been flushed by the writer. Hence in RMM , only certain data and function is allowed to be accessed at this stage of boot. Do you think the current wording of the 2nd rule encompass these intentions ? We could add a clarification that \"in warm boot path, care should be taken that only per-cpu locations are modified and reads of global data should be restricted to the ones which are meant to be accessed during this phase.\"\n\ninv() cache lines by secondaries for whole RMM area may throw out valid dirty lines thus causing incorrect operation.\n\nThe reason the whole RMM area is inv() in cold boot is because of BSS memzero and PIE fixups which is only a cold boot operation.",
      "parentUuid": "b46733f8_ac749f44",
      "range": {
        "startLine": 53,
        "startChar": 6,
        "endLine": 53,
        "endChar": 8
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56988837_102fbba5",
        "filename": "runtime/core/aarch64/head.S",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-07-17T13:57:00Z",
      "side": 1,
      "message": "i think that clarification would be good. let me add that to read me, since if a secondary core also modified global data that can be used outside its context on other CPUs, then the same problem applies.\nAnd ack on inv() cache lines, i incorrectly thought invalidate affects only local caches but it affects the entire shareability domain (OSH  default i think, when MMU disabled).",
      "parentUuid": "467bf892_38a9cee3",
      "range": {
        "startLine": 53,
        "startChar": 6,
        "endLine": 53,
        "endChar": 8
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea1cfb28_154d670d",
        "filename": "runtime/core/aarch64/head.S",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-07-17T16:09:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "56988837_102fbba5",
      "range": {
        "startLine": 53,
        "startChar": 6,
        "endLine": 53,
        "endChar": 8
      },
      "revId": "2d238d186b60f913fc1dc4c7b00202b33d143b3d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}