{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "10ce4cb6_e5381070",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000010
      },
      "writtenOn": "2023-09-25T10:21:24Z",
      "side": 1,
      "message": "Rewritten using Designated Initializers as we discussed offline",
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4288fbb_3e2887cb",
        "filename": "lib/xlat/include/xlat_defs.h",
        "patchSetId": 6
      },
      "lineNbr": 36,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T15:43:22Z",
      "side": 1,
      "message": "why do we need this?",
      "range": {
        "startLine": 36,
        "startChar": 28,
        "endLine": 36,
        "endChar": 30
      },
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62ef8665_829f5cba",
        "filename": "lib/xlat/include/xlat_high_va.h",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T15:43:22Z",
      "side": 1,
      "message": "NR_CPU_SLOTS",
      "range": {
        "startLine": 14,
        "startChar": 30,
        "endLine": 14,
        "endChar": 37
      },
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40ac5b48_5a144814",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T16:00:23Z",
      "side": 1,
      "message": "The VA space size for the high region needs to be a power of two, so round (RMM_NUM_PAGES_PER_STACK + GAP_PAGE_COUNT + XLAT_HIGH_VA_SLOT_NUM) up to the closest power of two so any addition or deletion of slot buffers won\u0027t make the xlat library to crash (see https://review.trustedfirmware.org/c/TF-RMM/tf-rmm/+/23425/6/lib/realm/src/include/buffer_private.h#9 for an example)\n\nAnother option would be to map the CPU Stacks right at the end of the current L3 page, for instance you can redefine GAP_PAGE_COUNT as\n\n#define GAP_PAGE_COUNT (XLAT_TABLE_ENTRIES - XLAT_HIGH_VA_SLOT_NUM - RMM_NUM_PAGES_PER_STACK)\n\nand\n\nCOMPILER_ASSERT((XLAT_HIGH_VA_SLOT_NUM + RMM_NUM_PAGES_PER_STACK) \u003c XLAT_TABLE_ENTRIES)\n\nThis way you know that your high VA region will use the whole L3 level table and you don\u0027t need to worry about the number of pages mapped.",
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fffb14bd_b6044ac7",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T16:36:54Z",
      "side": 1,
      "message": "Another option which is simpler (and I forgot about it) is to setup the VA size for the high region to be XLAT_TABLES_ENTRIES * PAGE_SIZE, regardless of the number of pages we map.",
      "parentUuid": "40ac5b48_5a144814",
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b664ffed_6ea2c95a",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T16:41:13Z",
      "side": 1,
      "message": "Double checked and I can see HIGH_VA_SIZE is alrady set to XLAT_TABLE_ENTRIES * PAGE_SIZE, so this can be dismissed.",
      "parentUuid": "fffb14bd_b6044ac7",
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9eb37482_21c0560d",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T15:43:22Z",
      "side": 1,
      "message": "struct xlat_ctx_cfg contains the immutable part of the xlat context so it only needs to be initialized once and can be used by all the contexts.\n\nThe workflow should be as follows:\n\n  - xlat_ctx_cfg_init() is called during cold boot. This will initialize the only struct xlat_ctx_cfg that you will need for all the contexts.\n  - the rest of the initialization (xlat_ctx_init() and xlat_arch_setup_mmu_cfg()) is done on the warm boot path. xlat_ctx_init() will accept the xlat_ctx_cfg structure that you initialized during cold boot.",
      "range": {
        "startLine": 79,
        "startChar": 28,
        "endLine": 79,
        "endChar": 49
      },
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d02486d_9f07072f",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T17:04:16Z",
      "side": 1,
      "message": "I re-reviewed the patch and you can dismiss this comment. I just realized that the PA for the stacks are different per CPU, which means you cannot share the xlat_mmap_region structures and therefore you cannot share the context configuration structures either.",
      "parentUuid": "9eb37482_21c0560d",
      "range": {
        "startLine": 79,
        "startChar": 28,
        "endLine": 79,
        "endChar": 49
      },
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "654b6546_7d309186",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 83,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T15:43:22Z",
      "side": 1,
      "message": "As per the workflow above, you only need one array of xlat_mmap_region structures, which will be shared across all the CPUs (all the CPUs use the same mappings). This memory mappings array will be used passed to xlat_ctx_cfg_init() only once during cold boot.",
      "range": {
        "startLine": 83,
        "startChar": 32,
        "endLine": 83,
        "endChar": 48
      },
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "decd50d2_61d1ee18",
        "filename": "lib/xlat/src/xlat_high_va.c",
        "patchSetId": 6
      },
      "lineNbr": 83,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-09-25T17:04:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "654b6546_7d309186",
      "range": {
        "startLine": 83,
        "startChar": 32,
        "endLine": 83,
        "endChar": 48
      },
      "revId": "a80b37879599f6b593f8330a936a15b42daa3fab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}