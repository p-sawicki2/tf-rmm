{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "10dd3c96_58b7ae35",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 105,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "nit: dont use same name for struct and object. similar comment to below instances.",
      "range": {
        "startLine": 105,
        "startChar": 17,
        "endLine": 105,
        "endChar": 24
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7ca7332_bdb68aa6",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 105,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "10dd3c96_58b7ae35",
      "range": {
        "startLine": 105,
        "startChar": 17,
        "endLine": 105,
        "endChar": 24
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63a19fdf_9ebc2899",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 116,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "_aarch64_vmsa",
      "range": {
        "startLine": 116,
        "startChar": 33,
        "endLine": 116,
        "endChar": 39
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "13811dc0_0d2690c2",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 116,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "63a19fdf_9ebc2899",
      "range": {
        "startLine": 116,
        "startChar": 33,
        "endLine": 116,
        "endChar": 39
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7c1b1aa_a3d7fc76",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 118,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "_aarch64_vmsa",
      "range": {
        "startLine": 118,
        "startChar": 36,
        "endLine": 118,
        "endChar": 44
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d503dde1_41593c14",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 118,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b7c1b1aa_a3d7fc76",
      "range": {
        "startLine": 118,
        "startChar": 36,
        "endLine": 118,
        "endChar": 44
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9380266_6c7c953d",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 140,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "...in the Stage 1 xlat tables as per aarch64 VMSA.",
      "range": {
        "startLine": 140,
        "startChar": 18,
        "endLine": 140,
        "endChar": 38
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a33f7025_00f25442",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 140,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d9380266_6c7c953d",
      "range": {
        "startLine": 140,
        "startChar": 18,
        "endLine": 140,
        "endChar": 38
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1d854d1_d310708a",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 225,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "better to use the aarch64 VMSA one rather than a different one. could use slot_to_va(i) as arg to this call.",
      "range": {
        "startLine": 225,
        "startChar": 5,
        "endLine": 225,
        "endChar": 55
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96da1067_75e3431a",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 225,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e1d854d1_d310708a",
      "range": {
        "startLine": 225,
        "startChar": 5,
        "endLine": 225,
        "endChar": 55
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4464b8e_ab518bb0",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 237,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "the graceful exit can be tested.",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 36
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16e169c8_d94e7b7e",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 237,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c4464b8e_ab518bb0",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 36
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f11a145_4f9b5568",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 242,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "I think this test is too complicated for the API it is trying to test. As I see it, there are 2  aspects to test: whether the NS buffer is mapped correctly, can we write to it.\n\nFor the first part, use realm_util_ API to ensure mapping is done in slot_buffer.\n\nFor the second part , you could just write random values to one buffer and use this API and compare it. And perhaps ns_buffer_read can be combined in the test so we get 2 APIs tested at one.",
      "range": {
        "startLine": 242,
        "startChar": 18,
        "endLine": 242,
        "endChar": 37
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b725f571_d4c3464a",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 242,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T10:12:33Z",
      "side": 1,
      "message": "For the first part of the test, I realized this is actually never tested with the current set of callbacks that we have. Check my answer to your comment on line 335 for more info.\n\nWRT the second point, I think it is not only enough with knowing if we can write, but also that we are writing properly, e.g. the offset passed is translated into the right offset within the granule, the size is respected and nothing above or below the area of the granule where we want to write has been affected. That\u0027s all that this test checks.\n\nWRT your last point, I think, when possible, we should keep the tests focused on one single API whenever possible, that way it should be easier to debug errors if something goes wrong and we can focus more easily on the specific aspects of that API",
      "parentUuid": "0f11a145_4f9b5568",
      "range": {
        "startLine": 242,
        "startChar": 18,
        "endLine": 242,
        "endChar": 37
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "306d3d17_8ace6333",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 242,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T10:39:00Z",
      "side": 1,
      "message": "Hmm, yes, the offset and size need to be checked, and that can be done in a easier way IMO. You could write with an offset (can be random) to granule of a given size (again random) and check. I find the windowing mechanism done currently too complicated for the purpose.\n\nOK, that is general policy. But if the test logic is more or less the same, it is better to combine multiple APIs to save code to review and maintain. It is just a thought but I dont have a strong opinion.",
      "parentUuid": "0f11a145_4f9b5568",
      "range": {
        "startLine": 242,
        "startChar": 18,
        "endLine": 242,
        "endChar": 37
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5dce0be_f6ff8db2",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 242,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Fixed as per our discussion this morning. Let me know if there is anything else that needs to be changed.",
      "parentUuid": "306d3d17_8ace6333",
      "range": {
        "startLine": 242,
        "startChar": 18,
        "endLine": 242,
        "endChar": 37
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5a70ae8_0fc225d4",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 276,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "Using numbers instead of basing it on GRANULE_SIZE will break these tests if the SIZE is changed in future. Recommend to base number on GRANULE_SIZE.",
      "range": {
        "startLine": 276,
        "startChar": 31,
        "endLine": 276,
        "endChar": 36
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "249c98fb_1ea8cffa",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 276,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5a70ae8_0fc225d4",
      "range": {
        "startLine": 276,
        "startChar": 31,
        "endLine": 276,
        "endChar": 36
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "706666bc_acb9ad6c",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 335,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T07:09:51Z",
      "side": 1,
      "message": "This can only happen if the same PA is mapped to 2 different CPUs SLOT_NS. I dont think we need to check this as slot_buffer allows to map same PA to 2 different CPUs. The `leak` comes down to memory arch and since this is host platform, there is not much point in testing it here.",
      "range": {
        "startLine": 334,
        "startChar": 38,
        "endLine": 335,
        "endChar": 64
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69a7e5a9_e9de2cdc",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 335,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T10:12:33Z",
      "side": 1,
      "message": "Actually, the point of this test is to check that the slot buffer library is able to keep different contexts for each CPU isolated (the slot buffer contexts are handled by the slot buffer module itself), so that having different PAs mapped to the same granule type (hence the same VA) at the same time on different CPUs is done properly.\n\nHowever, reviewing this test more closely, I\u0027m noticing that this is actually not tested at all: the callback used for the mapping returns the same address passed as argument, so it could happen that the library is doing the mapping all wrong or using the wrong context and that goes unnoticed here. And the same might be happening on other tests within this test group.\n\nOne solution that I see is that test_buffer_map_ret_pa() (or the counter one once I rename it as per your suggestions), doesn\u0027t return the same addr used as argument, but instead, once buffer_map_internal() has been called and a VA has been returned, instead of just ignore it, use a back conversion of that VA back to the \"PA\" that was mapped to it and return that address. If the slot buffer module used the right context, then the addr returned by test_buffer_map_ret_pa() should be same as used as argument, which will validate the tests.\n\nThoughts?",
      "parentUuid": "706666bc_acb9ad6c",
      "range": {
        "startLine": 334,
        "startChar": 38,
        "endLine": 335,
        "endChar": 64
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c11762b_fbfc65a1",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 335,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-01-13T10:39:00Z",
      "side": 1,
      "message": "Hmm the testing needs to define the purpose carefully when dealing with VA and PA on host platform. The point of the test was not clear from the description.\n\nIf only the Mapping according to VMSA is to be tested, then the bufeer_map_internal() return + a validation using realm_test_util_slot_va_from_pa() is enough\n\nIf the mapped buffer needs to be written to, then PA needs to be used through out, but as long as the former case is tested, this case can just use the PA returned and this is fine.\n\n\nThe previous tests are doing the right thing as AFAICS. For this one, we need to define the objective correctly and then the implementation can be done accordingly.",
      "parentUuid": "69a7e5a9_e9de2cdc",
      "range": {
        "startLine": 334,
        "startChar": 38,
        "endLine": 335,
        "endChar": 64
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3a534cd_6f482d2b",
        "filename": "lib/realm/tests/buffer.cpp",
        "patchSetId": 19
      },
      "lineNbr": 335,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2023-01-13T17:18:04Z",
      "side": 1,
      "message": "Reworked as per our discussion this morning.",
      "parentUuid": "0c11762b_fbfc65a1",
      "range": {
        "startLine": 334,
        "startChar": 38,
        "endLine": 335,
        "endChar": 64
      },
      "revId": "1c106cc949a862f49f1ba848dd8df5e5ac428190",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}