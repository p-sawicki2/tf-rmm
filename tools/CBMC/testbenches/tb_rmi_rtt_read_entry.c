/*
 * (C) COPYRIGHT 2021 Arm Limited or its affiliates
 * ALL RIGHTS RESERVED
 *
 * This file was AUTOGENERATED from the RMM specification.
 * RMM specification source version: 9f097087-dirty
 */

#include "tb.h"
#include "tb_rmi_rtt_read_entry.h"

bool tb_rmi_rtt_read_entry(
    uint64_t rd,
    uint64_t ipa,
    int64_t level)
{
    // Initialize registers
    struct tb_regs __tb_regs = __tb_arb_regs();
    __tb_regs.X0 = SMC_RMM_RTT_READ_ENTRY;
    __tb_regs.X1 = (uint64_t)rd;
    __tb_regs.X2 = (uint64_t)ipa;
    __tb_regs.X3 = (uint64_t)level;

    // Initialize global state
    __init_global_state(__tb_regs.X0);

    // Declare context variables
    struct rmm_rtt_walk_result walk;
    struct rmm_rtt_entry rtte;

    // Assign context variables before command execution
    walk = RttWalk(
        rd, ipa, level);
    rtte = RttEntryFromDescriptor(desc);

    // Pre-conditions
    bool failure_rd_align_pre = !AddrIsGranuleAligned(rd);
    bool failure_rd_bound_pre = !PaIsDelegable(rd);
    bool failure_rd_state_pre = Granule(rd).state != RD;
    bool failure_level_bound_pre = !RttLevelIsValid(rd, level);
    bool failure_ipa_align_pre = !AddrIsRttLevelAligned(ipa, level);
    bool failure_ipa_bound_pre = UInt(ipa) >= (pow(2, Realm(rd).ipa_width));
    bool no_failures_pre = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_level_bound_pre
        && !failure_ipa_align_pre
        && !failure_ipa_bound_pre;
    bool success_state_invalid_pre = (walk.entry.state == UNASSIGNED || walk.entry.state == UNASSIGNED_NS);
    bool success_state_prot_pre = (walk.entry.state == ASSIGNED || walk.entry.state == TABLE);
    bool success_state_unprot_pre = walk.entry.state == ASSIGNED_NS;
    bool success_ripas_unprot_pre = (walk.entry.state != UNASSIGNED && walk.entry.state != ASSIGNED);

    // Execute command and read the result.
    tb_handle_smc(&__tb_regs);
    uint64_t result =  __tb_regs.X0;
    uint64_t walk_level =  __tb_regs.X1;
    uint64_t state =  __tb_regs.X2;
    uint64_t desc =  __tb_regs.X3;
    uint64_t ripas =  __tb_regs.X4;

    // Assign context variables after command execution
    walk = RttWalk(
        rd, ipa, level);
    rtte = RttEntryFromDescriptor(desc);

    // Post-conditions
    bool failure_rd_align_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_rd_bound_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_rd_state_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_level_bound_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_ipa_align_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_ipa_bound_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool success_state_post = state == RttEntryState(walk.entry.state);
    bool success_state_invalid_post = (rtte.MemAttr == Zeros() && rtte.S2AP == Zeros() && rtte.SH == Zeros() && rtte.addr == Zeros());
    bool success_state_prot_post = (rtte.MemAttr == Zeros() && rtte.S2AP == Zeros() && rtte.SH == Zeros() && rtte.addr == walk.entry.addr);
    bool success_state_unprot_post = (rtte.MemAttr == walk.entry.MemAttr && rtte.S2AP == walk.entry.S2AP && rtte.SH == walk.entry.SH && rtte.addr == walk.entry.addr);
    bool success_ripas_unprot_post = ripas == RMI_EMPTY;

    // Failure condition assertions
    bool prop_failure_rd_align_ante = failure_rd_align_pre;
    __COVER(prop_failure_rd_align_ante);
    if (prop_failure_rd_align_ante) {
        bool prop_failure_rd_align_cons = failure_rd_align_post;
        __COVER(prop_failure_rd_align_cons);
        __ASSERT(prop_failure_rd_align_cons, "prop_failure_rd_align_cons");
    }

    bool prop_failure_rd_bound_ante = !failure_rd_align_pre
        && failure_rd_bound_pre;
    __COVER(prop_failure_rd_bound_ante);
    if (prop_failure_rd_bound_ante) {
        bool prop_failure_rd_bound_cons = failure_rd_bound_post;
        __COVER(prop_failure_rd_bound_cons);
        __ASSERT(prop_failure_rd_bound_cons, "prop_failure_rd_bound_cons");
    }

    bool prop_failure_rd_state_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && failure_rd_state_pre;
    __COVER(prop_failure_rd_state_ante);
    if (prop_failure_rd_state_ante) {
        bool prop_failure_rd_state_cons = failure_rd_state_post;
        __COVER(prop_failure_rd_state_cons);
        __ASSERT(prop_failure_rd_state_cons, "prop_failure_rd_state_cons");
    }

    bool prop_failure_level_bound_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && failure_level_bound_pre;
    __COVER(prop_failure_level_bound_ante);
    if (prop_failure_level_bound_ante) {
        bool prop_failure_level_bound_cons = failure_level_bound_post;
        __COVER(prop_failure_level_bound_cons);
        __ASSERT(prop_failure_level_bound_cons, "prop_failure_level_bound_cons");
    }

    bool prop_failure_ipa_align_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_level_bound_pre
        && failure_ipa_align_pre;
    __COVER(prop_failure_ipa_align_ante);
    if (prop_failure_ipa_align_ante) {
        bool prop_failure_ipa_align_cons = failure_ipa_align_post;
        __COVER(prop_failure_ipa_align_cons);
        __ASSERT(prop_failure_ipa_align_cons, "prop_failure_ipa_align_cons");
    }

    bool prop_failure_ipa_bound_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_level_bound_pre
        && !failure_ipa_align_pre
        && failure_ipa_bound_pre;
    __COVER(prop_failure_ipa_bound_ante);
    if (prop_failure_ipa_bound_ante) {
        bool prop_failure_ipa_bound_cons = failure_ipa_bound_post;
        __COVER(prop_failure_ipa_bound_cons);
        __ASSERT(prop_failure_ipa_bound_cons, "prop_failure_ipa_bound_cons");
    }

    // Result assertion
    bool prop_result_ante = no_failures_pre;
    __COVER(prop_result_ante);
    if (prop_result_ante) {
        bool prop_result_cons = result == RMI_SUCCESS;
        __COVER(prop_result_cons);
        __ASSERT(prop_result_cons, "prop_result_cons");
    }

    // Success condition assertions
    bool prop_success_state_ante = no_failures_pre;
    __COVER(prop_success_state_ante);
    if (prop_success_state_ante) {
        bool prop_success_state_cons = success_state_post;
        __COVER(prop_success_state_cons);
        __ASSERT(prop_success_state_cons, "prop_success_state_cons");
    }

    bool prop_success_state_invalid_ante = no_failures_pre
        && success_state_invalid_pre;
    __COVER(prop_success_state_invalid_ante);
    if (prop_success_state_invalid_ante) {
        bool prop_success_state_invalid_cons = success_state_invalid_post;
        __COVER(prop_success_state_invalid_cons);
        __ASSERT(prop_success_state_invalid_cons, "prop_success_state_invalid_cons");
    }

    bool prop_success_state_prot_ante = no_failures_pre
        && success_state_prot_pre;
    __COVER(prop_success_state_prot_ante);
    if (prop_success_state_prot_ante) {
        bool prop_success_state_prot_cons = success_state_prot_post;
        __COVER(prop_success_state_prot_cons);
        __ASSERT(prop_success_state_prot_cons, "prop_success_state_prot_cons");
    }

    bool prop_success_state_unprot_ante = no_failures_pre
        && success_state_unprot_pre;
    __COVER(prop_success_state_unprot_ante);
    if (prop_success_state_unprot_ante) {
        bool prop_success_state_unprot_cons = success_state_unprot_post;
        __COVER(prop_success_state_unprot_cons);
        __ASSERT(prop_success_state_unprot_cons, "prop_success_state_unprot_cons");
    }

    bool prop_success_ripas_unprot_ante = no_failures_pre
        && success_ripas_unprot_pre;
    __COVER(prop_success_ripas_unprot_ante);
    if (prop_success_ripas_unprot_ante) {
        bool prop_success_ripas_unprot_cons = success_ripas_unprot_post;
        __COVER(prop_success_ripas_unprot_cons);
        __ASSERT(prop_success_ripas_unprot_cons, "prop_success_ripas_unprot_cons");
    }

    // Assertion used to check consistency of the testbench
    __tb_expect_fail();

    return no_failures_pre;
}

