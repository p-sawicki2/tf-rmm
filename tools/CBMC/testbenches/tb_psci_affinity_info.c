/*
 * (C) COPYRIGHT 2021 Arm Limited or its affiliates
 * ALL RIGHTS RESERVED
 *
 * This file was AUTOGENERATED from the RMM specification.
 * RMM specification source version: 9f097087-dirty
 */

#include "tb.h"
#include "tb_psci_affinity_info.h"

bool tb_psci_affinity_info(
    uint64_t target_affinity,
    uint32_t lowest_affinity_level)
{
    // Initialize registers
    struct tb_regs __tb_regs = __tb_arb_regs();
    __tb_regs.X0 = SMC_RMM_AFFINITY_INFO;
    __tb_regs.X1 = (uint64_t)target_affinity;
    __tb_regs.X2 = (uint64_t)lowest_affinity_level;

    // Initialize global state
    __init_global_state(__tb_regs.X0);

    // Declare context variables
    struct rmm_rec target_rec;

    // Assign context variables before command execution
    target_rec = RecFromMpidr(
        target_affinity);

    // Pre-conditions
    bool failure_target_bound_pre = lowest_affinity_level != 0;
    bool failure_target_match_pre = !MpidrIsUsed(target_affinity);
    bool no_failures_pre = !failure_target_bound_pre
        && !failure_target_match_pre;
    bool success_runnable_pre = target_rec.flags.runnable == RUNNABLE;
    bool success_not_runnable_pre = target_rec.flags.runnable == NOT_RUNNABLE;

    // Execute command and read the result.
    tb_handle_smc(&__tb_regs);
    uint64_t result =  __tb_regs.X0;

    // Assign context variables after command execution
    target_rec = RecFromMpidr(
        target_affinity);

    // Post-conditions
    bool failure_target_bound_post = result == PSCI_INVALID_PARAMETERS;
    bool failure_target_match_post = result == PSCI_INVALID_PARAMETERS;
    bool success_runnable_post = result == PSCI_SUCCESS;
    bool success_not_runnable_post = result == PSCI_OFF;

    // Assertion used to check consistency of the testbench
    __tb_expect_fail();

    return no_failures_pre;
}

