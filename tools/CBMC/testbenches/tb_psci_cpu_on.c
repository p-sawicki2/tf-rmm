/*
 * (C) COPYRIGHT 2021 Arm Limited or its affiliates
 * ALL RIGHTS RESERVED
 *
 * This file was AUTOGENERATED from the RMM specification.
 * RMM specification source version: e9d4d747
 */

#include "tb.h"
#include "tb_psci_cpu_on.h"

bool tb_psci_cpu_on(
    uint64_t target_cpu,
    uint64_t entry_point_address,
    uint32_t context_id)
{
    // Initialize registers
    struct tb_regs __tb_regs = __tb_arb_regs();
    __tb_regs.X0 = SMC_RMM_CPU_ON;
    __tb_regs.X1 = (uint64_t)target_cpu;
    __tb_regs.X2 = (uint64_t)entry_point_address;
    __tb_regs.X3 = (uint64_t)context_id;

    // Initialize global state
    __init_global_state(__tb_regs.X0);

    // Declare context variables
    struct rmm_realm realm;
    struct rmm_rec target_rec;

    // Assign context variables before command execution
    realm = CurrentRealm();
    target_rec = RecFromMpidr(target_cpu);

    // Pre-conditions
    bool failure_entry_pre = !AddrIsProtected(entry_point_address, realm);
    bool failure_mpidr_pre = !MpidrIsUsed(target_cpu);
    bool failure_runnable_pre = target_rec.flags.runnable == RUNNABLE;
    bool no_failures_pre = !failure_entry_pre
        && !failure_mpidr_pre
        && !failure_runnable_pre;
    bool success_sysreg_pre = __tb_arb_bool();

    // Execute command
    uint64_t result = tb_handle_smc(&__tb_regs);

    // Assign context variables after command execution
    realm = CurrentRealm();
    target_rec = RecFromMpidr(target_cpu);

    // Post-conditions
    bool failure_entry_post = result == PSCI_INVALID_ADDRESS;
    bool failure_mpidr_post = result == PSCI_INVALID_PARAMETERS;
    bool failure_runnable_post = result == PSCI_ALREADY_ON;
    bool success_entry_post = target_rec.pc == entry_point_address;
    bool success_runnable_post = target_rec.flags.runnable == RUNNABLE;
    bool success_sysreg_post = success_sysreg_pre;

    // Assertion used to check consistency of the testbench
    __tb_expect_fail();

    return no_failures_pre;
}

void entry_point(
    void)
{
    tb_psci_cpu_on(nondet_uint64_t(), nondet_uint64_t(), nondet_uint32_t());
}

