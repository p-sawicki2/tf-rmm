/*
 * (C) COPYRIGHT 2021 Arm Limited or its affiliates
 * ALL RIGHTS RESERVED
 *
 * This file was AUTOGENERATED from the RMM specification.
 * RMM specification source version: 9f097087-dirty
 */

#include "tb.h"
#include "tb_rsi_measurement_extend.h"

bool tb_rsi_measurement_extend(
    uint64_t index,
    uint64_t size,
    uint64_t value_0,
    uint64_t value_1,
    uint64_t value_2,
    uint64_t value_3,
    uint64_t value_4,
    uint64_t value_5,
    uint64_t value_6,
    uint64_t value_7)
{
    // Initialize registers
    struct tb_regs __tb_regs = __tb_arb_regs();
    __tb_regs.X0 = SMC_RMM_MEASUREMENT_EXTEND;
    __tb_regs.X1 = (uint64_t)index;
    __tb_regs.X10 = (uint64_t)value_7;
    __tb_regs.X2 = (uint64_t)size;
    __tb_regs.X3 = (uint64_t)value_0;
    __tb_regs.X4 = (uint64_t)value_1;
    __tb_regs.X5 = (uint64_t)value_2;
    __tb_regs.X6 = (uint64_t)value_3;
    __tb_regs.X7 = (uint64_t)value_4;
    __tb_regs.X8 = (uint64_t)value_5;
    __tb_regs.X9 = (uint64_t)value_6;

    // Initialize global state
    __init_global_state(__tb_regs.X0);

    // Declare context variables
    struct rmm_realm realm;
    uint512_t meas_old;

    // Assign context variables before command execution
    realm = CurrentRealm();
    meas_old = CurrentRealm().measurements[index];

    // Pre-conditions
    bool failure_index_bound_pre = index < 1 || index > 4;
    bool failure_size_bound_pre = size > 64;
    bool no_failures_pre = !failure_index_bound_pre
        && !failure_size_bound_pre;

    // Execute command and read the result.
    tb_handle_smc(&__tb_regs);
    uint64_t result =  __tb_regs.X0;

    // Assign context variables after command execution
    realm = CurrentRealm();

    // Post-conditions
    bool failure_index_bound_post = result == RSI_ERROR_INPUT;
    bool failure_size_bound_post = result == RSI_ERROR_INPUT;
    bool success_realm_meas_post = realm.measurements[index] == RemExtend(realm.hash_algo, meas_old, [value_0, value_1, value_2, value_3, value_4, value_5, value_6, value_7], size);

    // Failure condition assertions
    bool prop_failure_index_bound_ante = failure_index_bound_pre;
    __COVER(prop_failure_index_bound_ante);
    if (prop_failure_index_bound_ante) {
        bool prop_failure_index_bound_cons = failure_index_bound_post;
        __COVER(prop_failure_index_bound_cons);
        __ASSERT(prop_failure_index_bound_cons, "prop_failure_index_bound_cons");
    }

    bool prop_failure_size_bound_ante = !failure_index_bound_pre
        && failure_size_bound_pre;
    __COVER(prop_failure_size_bound_ante);
    if (prop_failure_size_bound_ante) {
        bool prop_failure_size_bound_cons = failure_size_bound_post;
        __COVER(prop_failure_size_bound_cons);
        __ASSERT(prop_failure_size_bound_cons, "prop_failure_size_bound_cons");
    }

    // Result assertion
    bool prop_result_ante = no_failures_pre;
    __COVER(prop_result_ante);
    if (prop_result_ante) {
        bool prop_result_cons = result == RSI_SUCCESS;
        __COVER(prop_result_cons);
        __ASSERT(prop_result_cons, "prop_result_cons");
    }

    // Success condition assertions
    bool prop_success_realm_meas_ante = no_failures_pre;
    __COVER(prop_success_realm_meas_ante);
    if (prop_success_realm_meas_ante) {
        bool prop_success_realm_meas_cons = success_realm_meas_post;
        __COVER(prop_success_realm_meas_cons);
        __ASSERT(prop_success_realm_meas_cons, "prop_success_realm_meas_cons");
    }

    // Assertion used to check consistency of the testbench
    __tb_expect_fail();

    return no_failures_pre;
}

