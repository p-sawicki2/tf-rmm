/*
 * (C) COPYRIGHT 2021 Arm Limited or its affiliates
 * ALL RIGHTS RESERVED
 *
 * This file was AUTOGENERATED from the RMM specification.
 * RMM specification source version: 404016e5-dirty
 */

#include "tb.h"
#include "tb_rmi_rtt_init_ripas.h"

bool tb_rmi_rtt_init_ripas(
    uint64_t rd,
    uint64_t base,
    uint64_t top)
{
    // Initialize registers
    struct tb_regs __tb_regs = __tb_arb_regs();
    __tb_regs.X0 = SMC_RMM_RTT_INIT_RIPAS;
    __tb_regs.X1 = (uint64_t)rd;
    __tb_regs.X2 = (uint64_t)base;
    __tb_regs.X3 = (uint64_t)top;

    // Initialize global state
    __init_global_state(__tb_regs.X0);

    // Declare context variables
    struct rmm_realm realm;
    struct rmm_rtt_walk_result walk;
    uint64_t walk_top;

    // Assign context variables before command execution
    realm = Realm(rd);
    walk = RttWalk(rd, base,
    RMM_RTT_PAGE_LEVEL);
    walk_top = RttSkipEntriesWithRipas(
        Rtt(walk.rtt_addr),
        walk.level,
        base, top, FALSE);

    // Pre-conditions
    bool failure_rd_align_pre = !AddrIsGranuleAligned(rd);
    bool failure_rd_bound_pre = !PaIsDelegable(rd);
    bool failure_rd_state_pre = Granule(rd).state != RD;
    bool failure_size_valid_pre = UInt(top) <= UInt(base);
    bool failure_top_bound_pre = !AddrIsProtected(ToAddress(UInt(top) - RMM_GRANULE_SIZE), realm);
    bool failure_realm_state_pre = realm.state != NEW;
    bool failure_base_align_pre = !AddrIsRttLevelAligned(base, walk.level);
    bool failure_rtte_state_pre = walk.entry.state != UNASSIGNED;
    bool failure_top_align_pre = UInt(top) < UInt(AlignUpToRttLevel(ToAddress(UInt(base) + 1), walk.level));
    bool no_failures_pre = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_size_valid_pre
        && !failure_top_bound_pre
        && !failure_realm_state_pre
        && !failure_base_align_pre
        && !failure_rtte_state_pre
        && !failure_top_align_pre;

    // Execute command and read the result.
    tb_handle_smc(&__tb_regs);
    uint64_t result =  __tb_regs.X0;
    uint64_t out_top =  __tb_regs.X1;

    // Assign context variables after command execution
    walk = RttWalk(rd, base,
    RMM_RTT_PAGE_LEVEL);
    walk_top = RttSkipEntriesWithRipas(
        Rtt(walk.rtt_addr),
        walk.level,
        base, top, FALSE);

    // Post-conditions
    bool failure_rd_align_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_rd_bound_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_rd_state_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_size_valid_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_top_bound_post = ResultEqual_2(result, RMI_ERROR_INPUT);
    bool failure_realm_state_post = ResultEqual_2(result, RMI_ERROR_REALM);
    bool failure_base_align_post = ResultEqual_3(result, RMI_ERROR_RTT, walk.level);
    bool failure_rtte_state_post = ResultEqual_3(result, RMI_ERROR_RTT, walk.level);
    bool failure_top_align_post = ResultEqual_3(result, RMI_ERROR_RTT, walk.level);
    bool success_rtte_ripas_post = RttEntriesInRangeRipas(Rtt(walk.rtt_addr), walk.level, base, walk_top, RAM);
    bool success_rim_post = Realm(rd).measurements[0] == RimExtendRipas(realm, base, walk_top, walk.level);
    bool success_out_top_post = out_top == walk_top;

    // Failure condition assertions
    bool prop_failure_rd_align_ante = failure_rd_align_pre;
    __COVER(prop_failure_rd_align_ante);
    if (prop_failure_rd_align_ante) {
        bool prop_failure_rd_align_cons = failure_rd_align_post;
        __COVER(prop_failure_rd_align_cons);
        __ASSERT(prop_failure_rd_align_cons, "prop_failure_rd_align_cons");
    }

    bool prop_failure_rd_bound_ante = !failure_rd_align_pre
        && failure_rd_bound_pre;
    __COVER(prop_failure_rd_bound_ante);
    if (prop_failure_rd_bound_ante) {
        bool prop_failure_rd_bound_cons = failure_rd_bound_post;
        __COVER(prop_failure_rd_bound_cons);
        __ASSERT(prop_failure_rd_bound_cons, "prop_failure_rd_bound_cons");
    }

    bool prop_failure_rd_state_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && failure_rd_state_pre;
    __COVER(prop_failure_rd_state_ante);
    if (prop_failure_rd_state_ante) {
        bool prop_failure_rd_state_cons = failure_rd_state_post;
        __COVER(prop_failure_rd_state_cons);
        __ASSERT(prop_failure_rd_state_cons, "prop_failure_rd_state_cons");
    }

    bool prop_failure_size_valid_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && failure_size_valid_pre;
    __COVER(prop_failure_size_valid_ante);
    if (prop_failure_size_valid_ante) {
        bool prop_failure_size_valid_cons = failure_size_valid_post;
        __COVER(prop_failure_size_valid_cons);
        __ASSERT(prop_failure_size_valid_cons, "prop_failure_size_valid_cons");
    }

    bool prop_failure_top_bound_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_size_valid_pre
        && failure_top_bound_pre;
    __COVER(prop_failure_top_bound_ante);
    if (prop_failure_top_bound_ante) {
        bool prop_failure_top_bound_cons = failure_top_bound_post;
        __COVER(prop_failure_top_bound_cons);
        __ASSERT(prop_failure_top_bound_cons, "prop_failure_top_bound_cons");
    }

    bool prop_failure_realm_state_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_size_valid_pre
        && !failure_top_bound_pre
        && failure_realm_state_pre;
    __COVER(prop_failure_realm_state_ante);
    if (prop_failure_realm_state_ante) {
        bool prop_failure_realm_state_cons = failure_realm_state_post;
        __COVER(prop_failure_realm_state_cons);
        __ASSERT(prop_failure_realm_state_cons, "prop_failure_realm_state_cons");
    }

    bool prop_failure_base_align_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_size_valid_pre
        && !failure_top_bound_pre
        && !failure_realm_state_pre
        && failure_base_align_pre;
    __COVER(prop_failure_base_align_ante);
    if (prop_failure_base_align_ante) {
        bool prop_failure_base_align_cons = failure_base_align_post;
        __COVER(prop_failure_base_align_cons);
        __ASSERT(prop_failure_base_align_cons, "prop_failure_base_align_cons");
    }

    bool prop_failure_rtte_state_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_size_valid_pre
        && !failure_top_bound_pre
        && !failure_realm_state_pre
        && !failure_base_align_pre
        && failure_rtte_state_pre;
    __COVER(prop_failure_rtte_state_ante);
    if (prop_failure_rtte_state_ante) {
        bool prop_failure_rtte_state_cons = failure_rtte_state_post;
        __COVER(prop_failure_rtte_state_cons);
        __ASSERT(prop_failure_rtte_state_cons, "prop_failure_rtte_state_cons");
    }

    bool prop_failure_top_align_ante = !failure_rd_align_pre
        && !failure_rd_bound_pre
        && !failure_rd_state_pre
        && !failure_size_valid_pre
        && !failure_top_bound_pre
        && !failure_realm_state_pre
        && !failure_base_align_pre
        && !failure_rtte_state_pre
        && failure_top_align_pre;
    __COVER(prop_failure_top_align_ante);
    if (prop_failure_top_align_ante) {
        bool prop_failure_top_align_cons = failure_top_align_post;
        __COVER(prop_failure_top_align_cons);
        __ASSERT(prop_failure_top_align_cons, "prop_failure_top_align_cons");
    }

    // Result assertion
    bool prop_result_ante = no_failures_pre;
    __COVER(prop_result_ante);
    if (prop_result_ante) {
        bool prop_result_cons = result == RMI_SUCCESS;
        __COVER(prop_result_cons);
        __ASSERT(prop_result_cons, "prop_result_cons");
    }

    // Success condition assertions
    bool prop_success_rtte_ripas_ante = no_failures_pre;
    __COVER(prop_success_rtte_ripas_ante);
    if (prop_success_rtte_ripas_ante) {
        bool prop_success_rtte_ripas_cons = success_rtte_ripas_post && (result == RMI_SUCCESS);
        __COVER(prop_success_rtte_ripas_cons);
        __ASSERT(prop_success_rtte_ripas_cons, "prop_success_rtte_ripas_cons");
    }

    bool prop_success_rim_ante = no_failures_pre;
    __COVER(prop_success_rim_ante);
    if (prop_success_rim_ante) {
        bool prop_success_rim_cons = success_rim_post && (result == RMI_SUCCESS);
        __COVER(prop_success_rim_cons);
        __ASSERT(prop_success_rim_cons, "prop_success_rim_cons");
    }

    bool prop_success_out_top_ante = no_failures_pre;
    __COVER(prop_success_out_top_ante);
    if (prop_success_out_top_ante) {
        bool prop_success_out_top_cons = success_out_top_post && (result == RMI_SUCCESS);
        __COVER(prop_success_out_top_cons);
        __ASSERT(prop_success_out_top_cons, "prop_success_out_top_cons");
    }

    // Assertion used to check consistency of the testbench
    __tb_expect_fail();

    return no_failures_pre;
}

